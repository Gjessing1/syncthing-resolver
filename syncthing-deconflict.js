/**
 * Syncthing 3-Way Merge Deconflicter (Node.js)
 * 
 * Automatically resolves Syncthing conflicts by performing a git three-way merge.
 * Restricted to specific text-based file extensions for safety.
 */

require('dotenv').config();

const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');
const chokidar = require('chokidar');

// --- CONFIGURATION ---
const CONFIG = {
    watchPath: process.env.WATCH_PATH || './Notes/Work',
    syncRootPath: process.env.SYNC_ROOT || './',
    versionsDirName: process.env.VERSIONS_DIR || '.stversions',
    gitBinary: process.env.GIT_BIN || 'git',
    settleDelayMs: parseInt(process.env.SETTLE_DELAY) || 250,
    dryRun: process.env.DRY_RUN === 'true',
    
    // TOGGLE MERGE STRATEGY: 
    // true: No markers, but might duplicate lines (Safer for data)
    // false: Intelligent merge, but inserts <<<<<< markers on direct conflicts (Cleaner for Markdown)
    useUnionMerge: process.env.USE_UNION_MERGE === 'true', 

    // ONLY process these extensions (comma-separated, no dots)
    allowedExtensions: (process.env.ALLOWED_EXTENSIONS || 'md,txt,json,yaml,yml,org,canvas,taskpaper')
        .split(',')
        .map(e => e.trim().toLowerCase()),
    
    verbose: process.env.VERBOSE === 'true',
    
    // Create backup before merging (safety net)
    backupBeforeMerge: process.env.BACKUP_BEFORE_MERGE !== 'false',
    
    // Path to merge log file (empty = disabled)
    mergeLogPath: process.env.MERGE_LOG_PATH || '',
};

// Track in-flight operations to prevent double-processing
const processingFiles = new Set();

/**
 * Escape special regex characters in a string.
 */
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Log with timestamp.
 */
function log(level, message) {
    const timestamp = new Date().toISOString();
    console.log(`${timestamp} [${level}] ${message}`);
}

/**
 * Append entry to merge log file.
 */
function appendMergeLog(entry) {
    if (!CONFIG.mergeLogPath) return;
    
    try {
        const logPath = path.resolve(CONFIG.mergeLogPath);
        const dir = path.dirname(logPath);
        
        // Ensure directory exists
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        
        // Create file with header if it doesn't exist
        if (!fs.existsSync(logPath)) {
            fs.writeFileSync(logPath, '# Syncthing Merge Log\n\nAuto-generated by syncthing-deconflict.\n\n---\n\n');
        }
        
        fs.appendFileSync(logPath, entry);
        
    } catch (err) {
        log('WARN', `Failed to write merge log: ${err.message}`);
    }
}

/**
 * Format a merge log entry.
 * All paths are relative to the Syncthing root folder.
 */
function formatMergeLogEntry(originalFile, conflictFile, baseFile, status, error = null) {
    const now = new Date();
    const date = now.toISOString().split('T')[0];
    const time = now.toTimeString().split(' ')[0];
    
    let entry = `## ${date} ${time}\n\n`;
    entry += `- **Status:** ${status}\n`;
    entry += `- **File:** \`${originalFile}\`\n`;
    entry += `- **Conflict:** \`${conflictFile}\`\n`;
    entry += `- **Base:** \`${baseFile}\`\n`;
    
    if (error) {
        entry += `- **Error:** ${error}\n`;
    }
    
    entry += '\n---\n\n';
    return entry;
}

/**
 * Verify git is available before starting.
 */
function verifyGitAvailable() {
    const result = spawnSync(CONFIG.gitBinary, ['--version'], { encoding: 'utf8' });
    if (result.error) {
        throw new Error(`Git not found at "${CONFIG.gitBinary}": ${result.error.message}`);
    }
    if (CONFIG.verbose) {
        log('INFO', `Using ${result.stdout.trim()}`);
    }
}

/**
 * Executes the git 3-way merge command.
 * Returns the git exit code:
 *   0 = clean merge (no conflicts)
 *  >0 = number of conflict markers inserted
 *  -1 = dry run mode
 */
function mergeFiles(original, base, conflict) {
    // Dynamically include --union flag based on configuration
    const flags = CONFIG.useUnionMerge ? ['--union'] : [];
    const args = ['merge-file', ...flags, original, base, conflict];
    
    log('MERGE', `${CONFIG.gitBinary} ${args.join(' ')}`);

    if (CONFIG.dryRun) return -1;

    const result = spawnSync(CONFIG.gitBinary, args, { 
        stdio: 'pipe',
        encoding: 'utf8'
    });
    
    if (result.error) {
        throw new Error(`Git failed to execute: ${result.error.message}`);
    }
    
    // git merge-file returns:
    //   0 = clean merge
    //  >0 = number of conflicts
    // If not using --union, result.status > 0 is common and means markers were inserted.
    if (result.status !== null && result.status < 0) {
        throw new Error(`Git terminated by signal: ${result.signal}`);
    }
    
    if (result.stderr && result.stderr.trim()) {
        log('WARN', `Git stderr: ${result.stderr.trim()}`);
    }
    
    return result.status || 0;
}

/**
 * Attempt to clean up Syncthing's temporary ~syncthing~*.tmp files.
 * These can be left behind after conflict resolution.
 * Handles the case where the file might still be locked by Syncthing.
 */
function cleanupSyncthingTemp(originalFilePath) {
    const dir = path.dirname(originalFilePath);
    const fileName = path.basename(originalFilePath);
    
    // Syncthing temp files follow the pattern: ~syncthing~<filename>.tmp
    const tempFileName = `~syncthing~${fileName}.tmp`;
    const tempFilePath = path.join(dir, tempFileName);
    
    if (!fs.existsSync(tempFilePath)) {
        return; // No temp file to clean up
    }
    
    try {
        fs.unlinkSync(tempFilePath);
        log('CLEAN', `Removed Syncthing temp file: ${tempFileName}`);
    } catch (err) {
        if (err.code === 'EBUSY' || err.code === 'EACCES' || err.code === 'EPERM') {
            log('WARN', `Could not remove temp file "${tempFileName}" - likely still in use by Syncthing`);
        } else {
            log('WARN', `Failed to remove temp file "${tempFileName}": ${err.message}`);
        }
    }
}

/**
 * Scan for and remove leftover Syncthing temp files for conflicts at startup.
 * These are ghost files left behind from interrupted syncs.
 * Pattern: ~syncthing~*sync-conflict*.tmp
 */
function cleanupPreviousGhosts() {
    const absRoot = path.resolve(CONFIG.syncRootPath);
    log('GHOST', `Scanning for leftover conflict temp files...`);
    
    const allFiles = getAllFilesIncludingHidden(path.resolve(CONFIG.watchPath));
    const ghostRegex = /^~syncthing~.*sync-conflict.*\.tmp$/i;
    const ghosts = allFiles.filter(f => ghostRegex.test(path.basename(f)));
    
    if (ghosts.length === 0) {
        log('GHOST', 'No ghost temp files found.');
        return;
    }
    
    log('GHOST', `Found ${ghosts.length} ghost temp file(s). Cleaning up...`);
    
    for (const ghost of ghosts) {
        const relativePath = path.relative(absRoot, ghost);
        try {
            if (!CONFIG.dryRun) {
                fs.unlinkSync(ghost);
            }
            log('GHOST', `Removed: ${relativePath}${CONFIG.dryRun ? ' (dry run)' : ''}`);
        } catch (err) {
            if (err.code === 'EBUSY' || err.code === 'EACCES' || err.code === 'EPERM') {
                log('WARN', `Could not remove ghost "${relativePath}" - likely still in use`);
            } else {
                log('WARN', `Failed to remove ghost "${relativePath}": ${err.message}`);
            }
        }
    }
}

/**
 * Helper to find all files in a directory recursively (including hidden files starting with ~).
 * Used specifically for finding Syncthing temp files.
 */
function getAllFilesIncludingHidden(dirPath, arrayOfFiles = []) {
    if (!fs.existsSync(dirPath)) return [];
    
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {
        // Skip .dotfiles and node_modules, but allow ~syncthing~ files
        if ((file.startsWith('.') && !file.startsWith('~')) || file === 'node_modules') {
            return;
        }
        
        const fullPath = path.join(dirPath, file);
        try {
            if (fs.statSync(fullPath).isDirectory()) {
                getAllFilesIncludingHidden(fullPath, arrayOfFiles);
            } else {
                arrayOfFiles.push(fullPath);
            }
        } catch (err) {
            if (CONFIG.verbose) {
                log('WARN', `Could not stat ${fullPath}: ${err.message}`);
            }
        }
    });

    return arrayOfFiles;
}

/**
 * Helper to find all files in a directory recursively.
 */
function getAllFiles(dirPath, arrayOfFiles = []) {
    if (!fs.existsSync(dirPath)) return [];
    
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {
        if (file.startsWith('.') || file === 'node_modules') {
            return;
        }
        
        const fullPath = path.join(dirPath, file);
        try {
            if (fs.statSync(fullPath).isDirectory()) {
                getAllFiles(fullPath, arrayOfFiles);
            } else {
                arrayOfFiles.push(fullPath);
            }
        } catch (err) {
            if (CONFIG.verbose) {
                log('WARN', `Could not stat ${fullPath}: ${err.message}`);
            }
        }
    });

    return arrayOfFiles;
}

/**
 * Create a backup of a file before modifying it.
 */
function createBackup(filePath) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const dir = path.dirname(filePath);
    const ext = path.extname(filePath);
    const base = path.basename(filePath, ext);
    const backupPath = path.join(dir, `${base}.pre-merge-${timestamp}${ext}`);
    
    fs.copyFileSync(filePath, backupPath);
    return backupPath;
}

/**
 * Logic to handle a potential conflict file event.
 */
async function handleFileEvent(filePath, isStartupScan = false) {
    const absConflictPath = path.resolve(filePath);
    
    if (processingFiles.has(absConflictPath)) return;
    
    try {
        const stats = fs.lstatSync(absConflictPath);
        if (!stats.isFile()) return;
    } catch (err) {
        return;
    }

    const fileName = path.basename(absConflictPath);
    const conflictRegex = /^(.*?)(?:\.|%2F)sync-conflict-([0-9]{8})-([0-9]{6})-([A-Z0-9]{7})\.?(.*)$/i;
    const match = fileName.match(conflictRegex);

    if (!match) return;

    const [_full, baseName, _date, _time, _id, extension] = match;
    const extLower = (extension || '').toLowerCase();

    if (!CONFIG.allowedExtensions.includes(extLower)) {
        return;
    }

    processingFiles.add(absConflictPath);
    
    // Get absolute root path for relative path calculations
    const absRoot = path.resolve(CONFIG.syncRootPath);
    
    // Store relative paths for logging
    let relativeOriginalPath = '';
    let relativeConflictPath = '';
    let relativeBasePath = '';
    
    try {
        const source = isStartupScan ? 'SCAN' : 'FOUND';
        log(source, `Valid conflict file: ${fileName}`);

        if (!isStartupScan) {
            await new Promise(resolve => setTimeout(resolve, CONFIG.settleDelayMs));
        }

        if (!fs.existsSync(absConflictPath)) return;

        const originalFileName = extension ? `${baseName}.${extension}` : baseName;
        const originalFilePath = path.join(path.dirname(absConflictPath), originalFileName);

        // Calculate relative paths for logging
        relativeOriginalPath = path.relative(absRoot, originalFilePath);
        relativeConflictPath = path.relative(absRoot, absConflictPath);

        if (!fs.existsSync(originalFilePath)) {
            log('SKIP', `Original file "${relativeOriginalPath}" not found.`);
            return;
        }

        const relativeToRoot = path.relative(absRoot, originalFilePath);
        const relativeDir = path.dirname(relativeToRoot);
        const specificBackupFolder = path.join(absRoot, CONFIG.versionsDirName, relativeDir);

        if (!fs.existsSync(specificBackupFolder)) {
            log('SKIP', `No .stversions folder found at: ${specificBackupFolder}`);
            return;
        }

        const escapedBase = escapeRegex(baseName);
        const escapedExt = escapeRegex(extension);
        
        const backupRegex = extension
            ? new RegExp(`^${escapedBase}~([0-9]{8})-([0-9]{6})\\.${escapedExt}$`)
            : new RegExp(`^${escapedBase}~([0-9]{8})-([0-9]{6})$`);

        const backupCandidates = getAllFiles(specificBackupFolder)
            .filter(f => backupRegex.test(path.basename(f)))
            .sort()
            .reverse();

        if (backupCandidates.length === 0) {
            log('SKIP', `No historical versions found for "${relativeOriginalPath}"`);
            return;
        }

        const latestBackup = backupCandidates[0];
        relativeBasePath = path.relative(absRoot, latestBackup);
        
        log('INFO', `Merging: "${relativeOriginalPath}" (ours) + "${path.basename(absConflictPath)}" (theirs)`);

        if (CONFIG.backupBeforeMerge && !CONFIG.dryRun) {
            const backup = createBackup(originalFilePath);
            log('BACKUP', `Created pre-merge backup: ${path.basename(backup)}`);
        }

        const mergeExitCode = mergeFiles(originalFilePath, latestBackup, absConflictPath);
        
        log('CLEAN', `Deleting conflict file: ${fileName}`);
        if (!CONFIG.dryRun) {
            fs.unlinkSync(absConflictPath);
            
            // Attempt to clean up any Syncthing temp files for the conflict file
            cleanupSyncthingTemp(absConflictPath);
        }
        
        // Determine merge status based on exit code
        let status;
        if (CONFIG.dryRun) {
            status = 'Resolved (dry run)';
        } else if (mergeExitCode === 0) {
            status = 'Resolved (Clean Merge)';
            log('SUCCESS', `Resolved: ${relativeOriginalPath} - Clean Merge`);
        } else {
            status = `Resolved (Conflict Markers Inserted: ${mergeExitCode})`;
            log('SUCCESS', `Resolved: ${relativeOriginalPath} - ${mergeExitCode} conflict marker(s) inserted`);
        }
        
        appendMergeLog(formatMergeLogEntry(
            relativeOriginalPath,
            relativeConflictPath,
            relativeBasePath,
            status
        ));
        
    } catch (err) {
        log('ERROR', `Resolution failed: ${err.message}`);
        appendMergeLog(formatMergeLogEntry(
            relativeOriginalPath || fileName,
            relativeConflictPath || fileName,
            relativeBasePath || 'N/A',
            'Failed',
            err.message
        ));
    } finally {
        processingFiles.delete(absConflictPath);
    }
}

/**
 * Scan for existing conflict files at startup.
 * Ignores .tmp files to avoid processing Syncthing temp files.
 */
async function startupScan() {
    log('SCAN', `Scanning for existing conflicts in ${CONFIG.watchPath}...`);
    const allFiles = getAllFiles(path.resolve(CONFIG.watchPath));
    const conflictRegex = /sync-conflict-[0-9]{8}-[0-9]{6}-[A-Z0-9]{7}/i;
    const conflicts = allFiles.filter(f => {
        const basename = path.basename(f);
        // Must match conflict pattern AND must NOT be a .tmp file
        return conflictRegex.test(basename) && !basename.endsWith('.tmp');
    });
    
    if (conflicts.length === 0) {
        log('SCAN', 'No existing conflicts found.');
        return;
    }
    
    log('SCAN', `Found ${conflicts.length} existing conflict(s). Processing...`);
    for (const conflict of conflicts) {
        await handleFileEvent(conflict, true);
    }
}

// --- STARTUP ---

console.log('');
console.log('='.repeat(50));
console.log('  Syncthing 3-Way Merge Deconflicter');
console.log('='.repeat(50));
console.log('');

try {
    verifyGitAvailable();
} catch (err) {
    console.error(`FATAL: ${err.message}`);
    process.exit(1);
}

console.log(`Watching:          ${path.resolve(CONFIG.watchPath)}`);
console.log(`Sync Root:         ${path.resolve(CONFIG.syncRootPath)}`);
console.log(`Allowed Exts:      ${CONFIG.allowedExtensions.join(', ')}`);
console.log(`Union Merge Mode:  ${CONFIG.useUnionMerge ? 'ENABLED (Safe/Duplicate lines)' : 'DISABLED (Smart/Markers)'}`);
console.log(`Pre-merge Backup:  ${CONFIG.backupBeforeMerge ? 'enabled' : 'disabled'}`);
console.log(`Merge Log:         ${CONFIG.mergeLogPath || 'disabled'}`);

if (CONFIG.dryRun) {
    console.log('');
    console.log('*** DRY RUN MODE - No files will be modified ***');
}

console.log('');

// Step 1: Clean up any leftover ghost temp files from previous runs
cleanupPreviousGhosts();

console.log('');

// Step 2: Process any existing conflict files
startupScan().then(() => {
    console.log('');
    log('INFO', 'Starting file watcher...');
    
    const watcher = chokidar.watch(CONFIG.watchPath, {
        ignored: /(^|[\/\\])\.|node_modules/,
        persistent: true,
        ignoreInitial: true,
        awaitWriteFinish: {
            stabilityThreshold: 100,
            pollInterval: 50
        }
    });

    watcher
        .on('add', filePath => handleFileEvent(filePath))
        .on('change', filePath => handleFileEvent(filePath))
        .on('error', error => log('ERROR', `Watcher error: ${error}`));

    log('INFO', 'Watcher started. Waiting for conflict files...');
    console.log('');

    function shutdown() {
        console.log('');
        log('INFO', 'Shutting down...');
        watcher.close().then(() => {
            log('INFO', 'Watcher closed. Goodbye!');
            process.exit(0);
        });
    }

    process.on('SIGINT', shutdown);
    process.on('SIGTERM', shutdown);
});
