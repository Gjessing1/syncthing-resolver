/**
 * Syncthing 3-Way Merge Deconflicter (Node.js)
 * 
 * Automatically resolves Syncthing conflicts by performing a git three-way merge.
 * Restricted to specific text-based file extensions for safety.
 */

require('dotenv').config();

const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');
const chokidar = require('chokidar');

// --- CONFIGURATION ---
const CONFIG = {
    watchPath: process.env.WATCH_PATH || './Notes/Work',
    syncRootPath: process.env.SYNC_ROOT || './',
    versionsDirName: process.env.VERSIONS_DIR || '.stversions',
    gitBinary: process.env.GIT_BIN || 'git',
    settleDelayMs: parseInt(process.env.SETTLE_DELAY) || 250,
    dryRun: process.env.DRY_RUN === 'true',
    
    // ONLY process these extensions (comma-separated, no dots)
    allowedExtensions: (process.env.ALLOWED_EXTENSIONS || 'md,txt,json,yaml,yml,org,canvas,taskpaper')
        .split(',')
        .map(e => e.trim().toLowerCase()),
    
    verbose: process.env.VERBOSE === 'true',
    
    // Create backup before merging (safety net)
    backupBeforeMerge: process.env.BACKUP_BEFORE_MERGE !== 'false',
    
    // Path to merge log file (empty = disabled)
    mergeLogPath: process.env.MERGE_LOG_PATH || '',
};

// Track in-flight operations to prevent double-processing
const processingFiles = new Set();

/**
 * Escape special regex characters in a string.
 */
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Log with timestamp.
 */
function log(level, message) {
    const timestamp = new Date().toISOString();
    console.log(`${timestamp} [${level}] ${message}`);
}

/**
 * Append entry to merge log file.
 */
function appendMergeLog(entry) {
    if (!CONFIG.mergeLogPath) return;
    
    try {
        const logPath = path.resolve(CONFIG.mergeLogPath);
        const dir = path.dirname(logPath);
        
        // Ensure directory exists
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        
        // Create file with header if it doesn't exist
        if (!fs.existsSync(logPath)) {
            fs.writeFileSync(logPath, '# Syncthing Merge Log\n\nAuto-generated by syncthing-deconflict.\n\n---\n\n');
        }
        
        fs.appendFileSync(logPath, entry);
        
    } catch (err) {
        log('WARN', `Failed to write merge log: ${err.message}`);
    }
}

/**
 * Format a merge log entry.
 */
function formatMergeLogEntry(originalFile, conflictFile, baseFile, status, error = null) {
    const now = new Date();
    const date = now.toISOString().split('T')[0];
    const time = now.toTimeString().split(' ')[0];
    
    let entry = `## ${date} ${time}\n\n`;
    entry += `- **Status:** ${status}\n`;
    entry += `- **File:** \`${originalFile}\`\n`;
    entry += `- **Conflict:** \`${conflictFile}\`\n`;
    entry += `- **Base:** \`${baseFile}\`\n`;
    
    if (error) {
        entry += `- **Error:** ${error}\n`;
    }
    
    entry += '\n---\n\n';
    return entry;
}

/**
 * Verify git is available before starting.
 */
function verifyGitAvailable() {
    const result = spawnSync(CONFIG.gitBinary, ['--version'], { encoding: 'utf8' });
    if (result.error) {
        throw new Error(`Git not found at "${CONFIG.gitBinary}": ${result.error.message}`);
    }
    if (CONFIG.verbose) {
        log('INFO', `Using ${result.stdout.trim()}`);
    }
}

/**
 * Executes the git 3-way merge command.
 * Returns true on success, false on failure.
 */
function mergeFiles(original, base, conflict) {
    const args = ['merge-file', '--union', original, base, conflict];
    log('MERGE', `${CONFIG.gitBinary} ${args.join(' ')}`);

    if (CONFIG.dryRun) return true;

    const result = spawnSync(CONFIG.gitBinary, args, { 
        stdio: 'pipe',
        encoding: 'utf8'
    });
    
    // Check if spawn itself failed (e.g., binary not found)
    if (result.error) {
        throw new Error(`Git failed to execute: ${result.error.message}`);
    }
    
    // git merge-file returns:
    //   0 = clean merge
    //  >0 = number of conflicts (but --union auto-resolves these)
    //  -1 = error (but this comes as result.error, not status)
    // With --union, any positive exit code still means the merge completed
    
    if (result.status < 0) {
        // Negative status indicates a signal termination
        throw new Error(`Git terminated by signal: ${result.signal}`);
    }
    
    if (result.stderr && result.stderr.trim()) {
        log('WARN', `Git stderr: ${result.stderr.trim()}`);
    }
    
    return true;
}

/**
 * Helper to find all files in a directory recursively.
 */
function getAllFiles(dirPath, arrayOfFiles = []) {
    if (!fs.existsSync(dirPath)) return [];
    
    const files = fs.readdirSync(dirPath);

    files.forEach(file => {
        const fullPath = path.join(dirPath, file);
        try {
            if (fs.statSync(fullPath).isDirectory()) {
                getAllFiles(fullPath, arrayOfFiles);
            } else {
                arrayOfFiles.push(fullPath);
            }
        } catch (err) {
            // File may have been deleted between readdir and stat
            if (CONFIG.verbose) {
                log('WARN', `Could not stat ${fullPath}: ${err.message}`);
            }
        }
    });

    return arrayOfFiles;
}

/**
 * Create a backup of a file before modifying it.
 */
function createBackup(filePath) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const dir = path.dirname(filePath);
    const ext = path.extname(filePath);
    const base = path.basename(filePath, ext);
    const backupPath = path.join(dir, `${base}.pre-merge-${timestamp}${ext}`);
    
    fs.copyFileSync(filePath, backupPath);
    return backupPath;
}

/**
 * Logic to handle a potential conflict file event.
 */
async function handleFileEvent(filePath, isStartupScan = false) {
    const absConflictPath = path.resolve(filePath);
    
    // Debounce: skip if already processing this file
    if (processingFiles.has(absConflictPath)) {
        if (CONFIG.verbose) {
            log('DEBOUNCE', `Already processing: ${absConflictPath}`);
        }
        return;
    }
    
    // Check file exists and is a regular file
    try {
        const stats = fs.lstatSync(absConflictPath);
        if (!stats.isFile()) return;
    } catch (err) {
        // File doesn't exist or can't be accessed
        return;
    }

    const fileName = path.basename(absConflictPath);

    // Syncthing conflict pattern:
    // name.sync-conflict-YYYYMMDD-HHMMSS-XXXXXXX.ext
    // or URL-encoded variant with %2F
    const conflictRegex = /^(.*?)(?:\.|%2F)sync-conflict-([0-9]{8})-([0-9]{6})-([A-Z0-9]{7})\.?(.*)$/i;
    const match = fileName.match(conflictRegex);

    if (!match) return;

    const [_full, baseName, _date, _time, _id, extension] = match;
    const extLower = (extension || '').toLowerCase();

    // --- EXTENSION SECURITY CHECK ---
    // For extensionless files, check if empty string is in allowed list
    // (by default it's not, so extensionless files are skipped)
    if (!CONFIG.allowedExtensions.includes(extLower)) {
        if (CONFIG.verbose) {
            const extDisplay = extLower ? `.${extLower}` : '(no extension)';
            log('IGNORE', `Conflict found for "${fileName}", but extension "${extDisplay}" is not in allowed list.`);
        }
        return;
    }

    // Mark as processing to prevent duplicate handling
    processingFiles.add(absConflictPath);
    
    // Variables for merge log
    let originalFileName = '';
    let latestBackupName = '';
    
    try {
        const source = isStartupScan ? 'SCAN' : 'FOUND';
        log(source, `Valid conflict file: ${fileName}`);

        // Wait for Syncthing to finish disk I/O (skip on startup scan)
        if (!isStartupScan) {
            await new Promise(resolve => setTimeout(resolve, CONFIG.settleDelayMs));
        }

        // Verify file still exists after delay
        if (!fs.existsSync(absConflictPath)) {
            log('SKIP', `Conflict file disappeared: ${fileName}`);
            return;
        }

        // 1. Determine the path of the Original file
        originalFileName = extension ? `${baseName}.${extension}` : baseName;
        const originalFilePath = path.join(path.dirname(absConflictPath), originalFileName);

        if (!fs.existsSync(originalFilePath)) {
            log('SKIP', `Original file "${originalFileName}" not found.`);
            return;
        }

        // 2. Locate the backup in .stversions
        const absRoot = path.resolve(CONFIG.syncRootPath);
        const relativeToRoot = path.relative(absRoot, originalFilePath);
        const relativeDir = path.dirname(relativeToRoot);
        const specificBackupFolder = path.join(absRoot, CONFIG.versionsDirName, relativeDir);

        if (!fs.existsSync(specificBackupFolder)) {
            log('SKIP', `No .stversions folder found at: ${specificBackupFolder}`);
            return;
        }

        // Match the Syncthing versioning format: filename~YYYYMMDD-HHMMSS.ext
        const escapedBase = escapeRegex(baseName);
        const escapedExt = escapeRegex(extension);
        
        // Build regex that handles both files with and without extensions
        const backupRegex = extension
            ? new RegExp(`^${escapedBase}~([0-9]{8})-([0-9]{6})\\.${escapedExt}$`)
            : new RegExp(`^${escapedBase}~([0-9]{8})-([0-9]{6})$`);

        const backupCandidates = getAllFiles(specificBackupFolder)
            .filter(f => backupRegex.test(path.basename(f)))
            .sort()
            .reverse(); // Most recent first (lexicographic sort works for YYYYMMDD-HHMMSS)

        if (backupCandidates.length === 0) {
            log('SKIP', `No historical versions found for "${originalFileName}" in ${specificBackupFolder}`);
            return;
        }

        const latestBackup = backupCandidates[0];
        latestBackupName = path.basename(latestBackup);
        
        log('INFO', `Using base version: ${latestBackupName}`);
        log('INFO', `Merging: "${originalFileName}" (ours) + "${fileName}" (theirs)`);

        // Optional: Create safety backup before merging
        if (CONFIG.backupBeforeMerge && !CONFIG.dryRun) {
            const backup = createBackup(originalFilePath);
            log('BACKUP', `Created pre-merge backup: ${path.basename(backup)}`);
        }

        // Perform the merge
        mergeFiles(originalFilePath, latestBackup, absConflictPath);
        
        log('CLEAN', `Deleting conflict file: ${fileName}`);
        if (!CONFIG.dryRun) {
            fs.unlinkSync(absConflictPath);
        }
        
        log('SUCCESS', `Resolved: ${originalFileName}`);
        
        // Write to merge log
        appendMergeLog(formatMergeLogEntry(
            originalFileName,
            fileName,
            latestBackupName,
            CONFIG.dryRun ? '✅ Resolved (dry run)' : '✅ Resolved'
        ));
        
    } catch (err) {
        log('ERROR', `Resolution failed for ${fileName}: ${err.message}`);
        if (CONFIG.verbose) {
            console.error(err.stack);
        }
        
        // Write error to merge log
        appendMergeLog(formatMergeLogEntry(
            originalFileName || fileName,
            fileName,
            latestBackupName || 'N/A',
            '❌ Failed',
            err.message
        ));
        
    } finally {
        // Always remove from processing set
        processingFiles.delete(absConflictPath);
    }
}

/**
 * Scan for existing conflict files at startup.
 */
async function startupScan() {
    log('SCAN', `Scanning for existing conflicts in ${CONFIG.watchPath}...`);
    
    const allFiles = getAllFiles(path.resolve(CONFIG.watchPath));
    const conflictRegex = /sync-conflict-[0-9]{8}-[0-9]{6}-[A-Z0-9]{7}/i;
    
    const conflicts = allFiles.filter(f => conflictRegex.test(path.basename(f)));
    
    if (conflicts.length === 0) {
        log('SCAN', 'No existing conflicts found.');
        return;
    }
    
    log('SCAN', `Found ${conflicts.length} existing conflict(s). Processing...`);
    
    for (const conflict of conflicts) {
        await handleFileEvent(conflict, true);
    }
    
    log('SCAN', 'Startup scan complete.');
}

// --- STARTUP ---

console.log('');
console.log('='.repeat(50));
console.log('  Syncthing 3-Way Merge Deconflicter');
console.log('='.repeat(50));
console.log('');

try {
    verifyGitAvailable();
} catch (err) {
    console.error(`FATAL: ${err.message}`);
    process.exit(1);
}

console.log(`Watching:          ${path.resolve(CONFIG.watchPath)}`);
console.log(`Sync Root:         ${path.resolve(CONFIG.syncRootPath)}`);
console.log(`Versions Dir:      ${CONFIG.versionsDirName}`);
console.log(`Allowed Exts:      ${CONFIG.allowedExtensions.join(', ')}`);
console.log(`Settle Delay:      ${CONFIG.settleDelayMs}ms`);
console.log(`Pre-merge Backup:  ${CONFIG.backupBeforeMerge ? 'enabled' : 'disabled'}`);
console.log(`Merge Log:         ${CONFIG.mergeLogPath || 'disabled'}`);

if (CONFIG.dryRun) {
    console.log('');
    console.log('*** DRY RUN MODE - No files will be modified ***');
}

console.log('');

// Run startup scan, then start watcher
startupScan().then(() => {
    console.log('');
    log('INFO', 'Starting file watcher...');
    
    const watcher = chokidar.watch(CONFIG.watchPath, {
        ignored: /(^|[\/\\])\.|node_modules/,  // Ignore dotfiles and node_modules
        persistent: true,
        ignoreInitial: true,
        // Add some stability options
        awaitWriteFinish: {
            stabilityThreshold: 100,
            pollInterval: 50
        }
    });

    watcher
        .on('add', filePath => handleFileEvent(filePath))
        .on('change', filePath => handleFileEvent(filePath))
        .on('error', error => log('ERROR', `Watcher error: ${error}`));

    log('INFO', 'Watcher started. Waiting for conflict files...');
    console.log('');

    // Graceful shutdown
    function shutdown() {
        console.log('');
        log('INFO', 'Shutting down...');
        watcher.close().then(() => {
            log('INFO', 'Watcher closed. Goodbye!');
            process.exit(0);
        });
    }

    process.on('SIGINT', shutdown);
    process.on('SIGTERM', shutdown);
});
